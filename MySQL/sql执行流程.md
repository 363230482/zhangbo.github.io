
## 查询语句执行流程
客户端 -- 连接器(管理连接，权限验证) -- 查询缓存 -- 分析器(词法分析，语法分析) -- 优化器(执行计划生成，索引选择) -- 
执行器(操作引擎，返回结果) -- 储存引擎API

## update
redo log是innodb引擎层的，binlog是mysql server层的，所有引擎共用
redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志(row或statement格式)，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

update时，前面的流程和select一样，会清空该表的查询缓存。如update xxx where id = 2;

>1. 执行器先找引擎取ID=2这一行。ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。  
>2. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。  
>3. 引擎将这行新数据更新到内存(change buffer)中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。  
>4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。  
>5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

### current read(当前读) update更新时  
### consistent read(一致读) 可重复读:每个事务在启动时，会向事务系统申请一个全局transaction id，是严格顺序递增的。
每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务ID，记为 row trx_id。
同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

InnoDB 代码实现上，一个事务只需要在启动的时候，找到所有`已经提交`的事务 ID 的最大值，记为 `up_limit_id`；
然后声明说，“如果一个数据版本的 row trx_id 大于 up_limit_id，我就不认，我必须要找到它的上一个版本”。
当然，如果一个事务自己更新的数据，它自己还是要认的。

delete删除数据时，磁盘空间不会回收，但会标记为可复用，以便下次insert时，可以直接使用这些数据页或内存空间。  



