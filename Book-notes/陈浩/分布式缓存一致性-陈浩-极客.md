
# 缓存更新策略

## Cache Aside
1.读取时，先从缓存读，如没有，则从数据库读，然后更新缓存
2.写入时，先写数据库，然后让缓存失效
>让缓存失效而不是直接更新缓存，是因为如果两个并发写请求，可能后更新数据库的请求会先完成缓存的更新，导致缓存的写覆盖
>让缓存失效也会有这种情况，如一个读请求先来，此时缓存没有数据，会去读取数据库的老数据，
>然后在来一个写请求，写数据库成功后，在读请求更新缓存之前让缓存失效了，那么此时的读请求就会把老数据库更新到缓存造成脏数据。
>但这种情况出现的概率较低，一般来说读请求比写请求要快，不会出现在读取老数据库和更新缓存之间的时间内，写请求既要更新数据库，还能完成缓存失效的操作。

## Read Write Through
读取时读缓存，缓存没有数据时，由缓存服务自己去加载数据
写入时，也直接写缓存，如果缓存没有命中，则写数据库；如果命中缓存，则直接缓存，由缓存去同步更新数据库

## Write Behind Cache
读取时直接读缓存，没有则读数据库，然后更新缓存
写入时直接写缓存，然后在由缓存异步更新数据库，此时会有数据一致性问题。但性能好，全部写内存，而且缓存还可以合并多个写请求

## 自己创造
读取时和上面差不多
写入时，直接写数据库，然后由第三方的服务监听数据库(binlog)，在异步更新缓存，此时缓存在一定时间周期内可能会不一致。


