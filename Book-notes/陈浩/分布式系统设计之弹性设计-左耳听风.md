# 
在系统设计时，一定要考虑异常情况，预留手动配置开关入口，异常告警，异常感知，性能等因素。

## 故障和弹性

亚马逊的`Design For Failure`
故障不可避免，特别是在分布式环境下。所以我们要想尽一切办法来缩短故障恢复时间，提高系统可用性(几个9:99.9%等)  

## 隔离设计
服务隔离    
数据隔离    
服务和数据都隔离，易于实现，但成本高；都共享，开发难度大，安全性(特别是数据隔离)不高

## 异步通信
同步通信：简单，易于实现，实时性好；但无法并发，响应时间长，受限于响应最慢的服务，易引起雪崩。
异步通信：解耦，提高吞吐量，服务隔离，不会引起雪崩

请求响应式异步：收到请求立即返回’处理中‘，异步线程处理结果，然后轮询或推送响应结果  
直接订阅发布：类似线程池  
Broker订阅发布：MQ，依赖Broker的高可用  
事件驱动：  

## 幂等
接口响应一般有 成功/失败/超时 3种。对于前两种有明确的状态，但超时这种，我们无法得知到底是成功还是失败？

这种情况，我们可以让接口方提供一个查询接口，调用方在超时后，可以通过主动查询得知明确的结果。
也可以在接口方内部做接口幂等，这需要业务确认，以什么标识(UUID/Snowflake)做唯一约束来做幂等,数据库乐观锁等。
前端重复提交，可以让前端在提交时，生成一个唯一ID(在进入页面时生成，不是在提交时才生成)

## 服务的状态
无状态服务，函数式编程，可以很方便的扩展。
但现实肯定是有状态的，所以我们把状态储存到第三方的服务，不重要的存在如Redis等缓存，重要的存在Mysql,zookeeper等一致性服务中。
这导致服务有了依赖，也增加了网络开销，增加了响应时间。

有状态的服务，需要数据同步，需要考虑数据一致性：二阶段提交，Goosip，Paxos等CAP

## 补偿事务

## 重试
Spring的`@Retryable`
注意重试的策略(重试次数，间隔时间，重试的异常类型，业务场景，是否幂等)，哪些需要重试。

## 熔断
断路器：参见Hystrix，Closed - Half-Open - Open

## 限流
限流行为：拒绝服务，服务降级
限流算法：
1.计算器: 设定一个count，开始处理就+1，处理完成就-1，count超过一定值就拒绝。Java的`Semaphore`
2.FIFO队列/多队列(优先队列): 类似线程池，请求放入一个队列，processor从队列中处理请求
3.漏桶算法: 无法处理流量突刺
4.令牌桶算法: 可以平滑处理流量突刺等，在流量小的时候积攒令牌
5.动态限流：类型TCP的拥塞控制，动态计算一段时间内的响应时间等，内存和CPU消耗较大

目的：
1.向用户保证SLA，保证系统在某个速度下的响应时间和可用性
2.在SAAS环境下，限制单一用户的请求，避免单一用户占用过多的资源
3.为了应对突发的流量
4.节约成本，我们大部分服务都不会按照不常见的最大流量来部署，而是在有限的资源下承受较高的流量

## 降级
降低一致性：强一致性变为最终一致性
简化功能：不返回全量数据，只返回部分数据；简化业务流程
停止次要功能：停止不重要的功能，腾挪出更多的资源，如双十一等；对次要功能限流


