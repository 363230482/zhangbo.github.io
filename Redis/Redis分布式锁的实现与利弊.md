#1.实现方式
1.1 单节点  
* 加锁方式：set key value NX PX|EX time  
* 解锁方式：直接del指令，可能会造成删除掉其他线程加的锁，所以需要使用lua脚本来保证解锁的原子性：
```
if redis.call('get', KEYS[1]) == ARGV[1] then 
    return redis.call('del', KEYS[1]) 
else 
    return 0 end
```
* 优势：实现简单，可一定程度保证一致性
* 劣势：由于是单节点，所以无法保证高可用。
  可能会由于GC等造成的JVM停顿，导致锁过期后，应用线程还认为持有该锁，而造成同一时刻可能存在多个锁  

1.2 Redis集群
* 加锁与解锁方式与单节点一直
* 优势：由于是集群方式，可保证高可用
* 劣势：由于Redis集群，主从数据同步是异步方式，所以无法保证一致性。
比如一个线程刚注册一个锁到主节点，但数据还没来得及同步到从节点，此时主节点宕机，从节点提升为主节点，
此时从节点上还没有锁的信息，所以其他线程又可以注册新的锁，导致同一时间有多个锁。

1.3 Redlock
* 加锁方式：由多个独立的主节点(比如5个)，然后加锁的时候，分别在每个节点上注册加锁信息，
如果注册成功的节点数大于一半，且所花费的时间小于锁的持有时间，则加锁成功。
如果注册成功的节点数小于一半，或者注册锁的时间已经大于锁的持有时间，也算加锁失败，需要删除掉全部节点注册(包括注册失败的节点)的锁信息。
* 解锁方式：依次删除所有节点上的锁信息，与单节点的解锁方式一致。
* 优势：可保证可用性的同时，在一定程度的保证一致性。
* 劣势：实现太过复杂，且多个独立的主节点来单独实现分布式锁，资源可能会造成浪费。

1.4 Redission
* 使用lua脚本实现，引入了watch dog机制，解决GC停顿造成的影响。它有一个后台线程，默认在加锁成功后，每隔一段时间，会延长该锁的过期时间。  

#2.总结
由于Redis单节点不能保证可用性，但集群又侧重于CAP中的AP，不能保证一致性，所以一般建议分布式锁不选择Redis，
可选用Zookeeper或etcd等侧重CP的中间件实现。